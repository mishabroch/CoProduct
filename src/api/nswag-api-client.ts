//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.4.0.0 (NJsonSchema v11.3.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError } from "axios";
import type {
  AxiosInstance,
  AxiosRequestConfig,
  AxiosResponse,
  CancelToken,
} from "axios";

export interface IApiClient {
  getHello(): Promise<void>;
}

export class ApiClient implements IApiClient {
  protected instance: AxiosInstance;
  protected baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance || axios.create();

    this.baseUrl = baseUrl ?? "";
  }

  getHello(cancelToken?: CancelToken): Promise<void> {
    let url_ = this.baseUrl + "/";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {},
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetHello(_response);
      });
  }

  protected processGetHello(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(null as any);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<void>(null as any);
  }
}

export interface IFeatureRequestApiClient {
  /**
   * Создать новый feature request
   * @return Feature request успешно создан
   */
  create(body: CreateFeatureRequestDto): Promise<FeatureRequestResponseDto>;
  /**
   * Получить все feature requests
   * @return Список feature requests
   */
  findAll(): Promise<FeatureRequestResponseDto[]>;
  /**
   * Получить feature request по ID
   * @param id ID feature request
   * @return Feature request найден
   */
  findOne(id: string): Promise<FeatureRequestResponseDto>;
  /**
   * Обновить feature request
   * @param id ID feature request
   * @return Feature request обновлен
   */
  update(
    id: string,
    body: UpdateFeatureRequestDto
  ): Promise<FeatureRequestResponseDto>;
  /**
   * Удалить feature request
   * @param id ID feature request
   * @return Feature request удален
   */
  remove(id: string): Promise<FeatureRequestResponseDto>;
}

export class FeatureRequestApiClient implements IFeatureRequestApiClient {
  protected instance: AxiosInstance;
  protected baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance || axios.create();

    this.baseUrl = baseUrl ?? "";
  }

  /**
   * Создать новый feature request
   * @return Feature request успешно создан
   */
  create(
    body: CreateFeatureRequestDto,
    cancelToken?: CancelToken
  ): Promise<FeatureRequestResponseDto> {
    let url_ = this.baseUrl + "/api/feature-requests";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processCreate(_response);
      });
  }

  protected processCreate(
    response: AxiosResponse
  ): Promise<FeatureRequestResponseDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 201) {
      const _responseText = response.data;
      let result201: any = null;
      let resultData201 = _responseText;
      result201 = FeatureRequestResponseDto.fromJS(resultData201);
      return Promise.resolve<FeatureRequestResponseDto>(result201);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException(
        "\u041d\u0435\u0432\u0435\u0440\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435",
        status,
        _responseText,
        _headers
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<FeatureRequestResponseDto>(null as any);
  }

  /**
   * Получить все feature requests
   * @return Список feature requests
   */
  findAll(cancelToken?: CancelToken): Promise<FeatureRequestResponseDto[]> {
    let url_ = this.baseUrl + "/api/feature-requests";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processFindAll(_response);
      });
  }

  protected processFindAll(
    response: AxiosResponse
  ): Promise<FeatureRequestResponseDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      if (Array.isArray(resultData200)) {
        result200 = [] as any;
        for (let item of resultData200)
          result200!.push(FeatureRequestResponseDto.fromJS(item));
      } else {
        result200 = <any>null;
      }
      return Promise.resolve<FeatureRequestResponseDto[]>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<FeatureRequestResponseDto[]>(null as any);
  }

  /**
   * Получить feature request по ID
   * @param id ID feature request
   * @return Feature request найден
   */
  findOne(
    id: string,
    cancelToken?: CancelToken
  ): Promise<FeatureRequestResponseDto> {
    let url_ = this.baseUrl + "/api/feature-requests/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processFindOne(_response);
      });
  }

  protected processFindOne(
    response: AxiosResponse
  ): Promise<FeatureRequestResponseDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = FeatureRequestResponseDto.fromJS(resultData200);
      return Promise.resolve<FeatureRequestResponseDto>(result200);
    } else if (status === 404) {
      const _responseText = response.data;
      return throwException(
        "Feature request \u043d\u0435 \u043d\u0430\u0439\u0434\u0435\u043d",
        status,
        _responseText,
        _headers
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<FeatureRequestResponseDto>(null as any);
  }

  /**
   * Обновить feature request
   * @param id ID feature request
   * @return Feature request обновлен
   */
  update(
    id: string,
    body: UpdateFeatureRequestDto,
    cancelToken?: CancelToken
  ): Promise<FeatureRequestResponseDto> {
    let url_ = this.baseUrl + "/api/feature-requests/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: "PATCH",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processUpdate(_response);
      });
  }

  protected processUpdate(
    response: AxiosResponse
  ): Promise<FeatureRequestResponseDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = FeatureRequestResponseDto.fromJS(resultData200);
      return Promise.resolve<FeatureRequestResponseDto>(result200);
    } else if (status === 404) {
      const _responseText = response.data;
      return throwException(
        "Feature request \u043d\u0435 \u043d\u0430\u0439\u0434\u0435\u043d",
        status,
        _responseText,
        _headers
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<FeatureRequestResponseDto>(null as any);
  }

  /**
   * Удалить feature request
   * @param id ID feature request
   * @return Feature request удален
   */
  remove(
    id: string,
    cancelToken?: CancelToken
  ): Promise<FeatureRequestResponseDto> {
    let url_ = this.baseUrl + "/api/feature-requests/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "DELETE",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processRemove(_response);
      });
  }

  protected processRemove(
    response: AxiosResponse
  ): Promise<FeatureRequestResponseDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = FeatureRequestResponseDto.fromJS(resultData200);
      return Promise.resolve<FeatureRequestResponseDto>(result200);
    } else if (status === 404) {
      const _responseText = response.data;
      return throwException(
        "Feature request \u043d\u0435 \u043d\u0430\u0439\u0434\u0435\u043d",
        status,
        _responseText,
        _headers
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<FeatureRequestResponseDto>(null as any);
  }
}

export interface IPromptApiClient {
  /**
   * Создать новый промпт
   * @return Промпт успешно создан
   */
  create(body: CreatePromptDto): Promise<PromptResponseDto>;
  /**
   * Получить все промпты
   * @return Список промптов
   */
  findAll(): Promise<PromptResponseDto[]>;
  /**
   * Получить промпт по ID
   * @return Промпт найден
   */
  findOne(id: number): Promise<PromptResponseDto>;
  /**
   * Обновить промпт
   * @return Промпт обновлен
   */
  update(id: number, body: UpdatePromptDto): Promise<PromptResponseDto>;
  /**
   * Удалить промпт
   * @return Промпт удален
   */
  remove(id: number): Promise<PromptResponseDto>;
}

export class PromptApiClient implements IPromptApiClient {
  protected instance: AxiosInstance;
  protected baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =
    undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance || axios.create();

    this.baseUrl = baseUrl ?? "";
  }

  /**
   * Создать новый промпт
   * @return Промпт успешно создан
   */
  create(
    body: CreatePromptDto,
    cancelToken?: CancelToken
  ): Promise<PromptResponseDto> {
    let url_ = this.baseUrl + "/api/prompts";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processCreate(_response);
      });
  }

  protected processCreate(response: AxiosResponse): Promise<PromptResponseDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 201) {
      const _responseText = response.data;
      let result201: any = null;
      let resultData201 = _responseText;
      result201 = PromptResponseDto.fromJS(resultData201);
      return Promise.resolve<PromptResponseDto>(result201);
    } else if (status === 400) {
      const _responseText = response.data;
      return throwException(
        "\u041d\u0435\u0432\u0435\u0440\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435",
        status,
        _responseText,
        _headers
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<PromptResponseDto>(null as any);
  }

  /**
   * Получить все промпты
   * @return Список промптов
   */
  findAll(cancelToken?: CancelToken): Promise<PromptResponseDto[]> {
    let url_ = this.baseUrl + "/api/prompts";
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processFindAll(_response);
      });
  }

  protected processFindAll(
    response: AxiosResponse
  ): Promise<PromptResponseDto[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      if (Array.isArray(resultData200)) {
        result200 = [] as any;
        for (let item of resultData200)
          result200!.push(PromptResponseDto.fromJS(item));
      } else {
        result200 = <any>null;
      }
      return Promise.resolve<PromptResponseDto[]>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<PromptResponseDto[]>(null as any);
  }

  /**
   * Получить промпт по ID
   * @return Промпт найден
   */
  findOne(id: number, cancelToken?: CancelToken): Promise<PromptResponseDto> {
    let url_ = this.baseUrl + "/api/prompts/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "GET",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processFindOne(_response);
      });
  }

  protected processFindOne(
    response: AxiosResponse
  ): Promise<PromptResponseDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = PromptResponseDto.fromJS(resultData200);
      return Promise.resolve<PromptResponseDto>(result200);
    } else if (status === 404) {
      const _responseText = response.data;
      return throwException(
        "\u041f\u0440\u043e\u043c\u043f\u0442 \u043d\u0435 \u043d\u0430\u0439\u0434\u0435\u043d",
        status,
        _responseText,
        _headers
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<PromptResponseDto>(null as any);
  }

  /**
   * Обновить промпт
   * @return Промпт обновлен
   */
  update(
    id: number,
    body: UpdatePromptDto,
    cancelToken?: CancelToken
  ): Promise<PromptResponseDto> {
    let url_ = this.baseUrl + "/api/prompts/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
      data: content_,
      method: "PATCH",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processUpdate(_response);
      });
  }

  protected processUpdate(response: AxiosResponse): Promise<PromptResponseDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = PromptResponseDto.fromJS(resultData200);
      return Promise.resolve<PromptResponseDto>(result200);
    } else if (status === 404) {
      const _responseText = response.data;
      return throwException(
        "\u041f\u0440\u043e\u043c\u043f\u0442 \u043d\u0435 \u043d\u0430\u0439\u0434\u0435\u043d",
        status,
        _responseText,
        _headers
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<PromptResponseDto>(null as any);
  }

  /**
   * Удалить промпт
   * @return Промпт удален
   */
  remove(id: number, cancelToken?: CancelToken): Promise<PromptResponseDto> {
    let url_ = this.baseUrl + "/api/prompts/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
      method: "DELETE",
      url: url_,
      headers: {
        Accept: "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processRemove(_response);
      });
  }

  protected processRemove(response: AxiosResponse): Promise<PromptResponseDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (const k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = PromptResponseDto.fromJS(resultData200);
      return Promise.resolve<PromptResponseDto>(result200);
    } else if (status === 404) {
      const _responseText = response.data;
      return throwException(
        "\u041f\u0440\u043e\u043c\u043f\u0442 \u043d\u0435 \u043d\u0430\u0439\u0434\u0435\u043d",
        status,
        _responseText,
        _headers
      );
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<PromptResponseDto>(null as any);
  }
}

export class CreateFeatureRequestDto implements ICreateFeatureRequestDto {
  /** Имя клиента */
  customer!: string;
  /** Когда происходит действие */
  when?: string;
  /** Что хочет клиент */
  want?: string;
  /** Как это должно работать */
  how?: string;
  /** Для чего это нужно */
  soThat?: string;
  /** Feature requests */
  featureRequests?: string;
  /** ID промпта, использованного для создания */
  promptId?: number;
  constructor(data?: ICreateFeatureRequestDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property];
      }
      this.customer = _data["customer"];
      this.when = _data["when"];
      this.want = _data["want"];
      this.how = _data["how"];
      this.soThat = _data["soThat"];
      this.featureRequests = _data["featureRequests"];
      this.promptId = _data["promptId"];
    }
  }

  static fromJS(data: any): CreateFeatureRequestDto {
    data = typeof data === "object" ? data : {};
    let result = new CreateFeatureRequestDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property];
    }
    data["customer"] = this.customer;
    data["when"] = this.when;
    data["want"] = this.want;
    data["how"] = this.how;
    data["soThat"] = this.soThat;
    data["featureRequests"] = this.featureRequests;
    data["promptId"] = this.promptId;
    return data;
  }
}

export interface ICreateFeatureRequestDto {
  /** Имя клиента */
  customer: string;
  /** Когда происходит действие */
  when?: string;
  /** Что хочет клиент */
  want?: string;
  /** Как это должно работать */
  how?: string;
  /** Для чего это нужно */
  soThat?: string;
  /** Feature requests */
  featureRequests?: string;
  /** ID промпта, использованного для создания */
  promptId?: number;
}

export class FeatureRequestResponseDto implements IFeatureRequestResponseDto {
  /** Уникальный идентификатор */
  id!: number;
  /** Имя клиента */
  customer!: string;
  /** Когда происходит действие */
  when!: string;
  /** Что хочет клиент */
  want!: string;
  /** Как это должно работать */
  how!: string;
  /** Для чего это нужно */
  soThat!: string;
  /** Feature requests */
  featureRequests!: string;
  /** Дата создания */
  createdAt!: Date;
  /** Дата последнего обновления */
  updatedAt!: Date;
  /** ID промпта, использованного для создания */
  promptId?: number;
  /** Промпт, использованный для создания */
  prompt?: any;
  constructor(data?: IFeatureRequestResponseDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property];
      }
      this.id = _data["id"];
      this.customer = _data["customer"];
      this.when = _data["when"];
      this.want = _data["want"];
      this.how = _data["how"];
      this.soThat = _data["soThat"];
      this.featureRequests = _data["featureRequests"];
      this.createdAt = _data["createdAt"]
        ? new Date(_data["createdAt"].toString())
        : <any>undefined;
      this.updatedAt = _data["updatedAt"]
        ? new Date(_data["updatedAt"].toString())
        : <any>undefined;
      this.promptId = _data["promptId"];
      this.prompt = _data["prompt"];
    }
  }

  static fromJS(data: any): FeatureRequestResponseDto {
    data = typeof data === "object" ? data : {};
    let result = new FeatureRequestResponseDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property];
    }
    data["id"] = this.id;
    data["customer"] = this.customer;
    data["when"] = this.when;
    data["want"] = this.want;
    data["how"] = this.how;
    data["soThat"] = this.soThat;
    data["featureRequests"] = this.featureRequests;
    data["createdAt"] = this.createdAt
      ? this.createdAt.toISOString()
      : <any>undefined;
    data["updatedAt"] = this.updatedAt
      ? this.updatedAt.toISOString()
      : <any>undefined;
    data["promptId"] = this.promptId;
    data["prompt"] = this.prompt;
    return data;
  }
}

export interface IFeatureRequestResponseDto {
  /** Уникальный идентификатор */
  id: number;
  /** Имя клиента */
  customer: string;
  /** Когда происходит действие */
  when: string;
  /** Что хочет клиент */
  want: string;
  /** Как это должно работать */
  how: string;
  /** Для чего это нужно */
  soThat: string;
  /** Feature requests */
  featureRequests: string;
  /** Дата создания */
  createdAt: Date;
  /** Дата последнего обновления */
  updatedAt: Date;
  /** ID промпта, использованного для создания */
  promptId?: number;
  /** Промпт, использованный для создания */
  prompt?: any;
}

export class UpdateFeatureRequestDto implements IUpdateFeatureRequestDto {
  /** Имя клиента */
  customer?: string;
  /** Когда происходит действие */
  when?: string;
  /** Что хочет клиент */
  want?: string;
  /** Как это должно работать */
  how?: string;
  /** Для чего это нужно */
  soThat?: string;
  /** Feature requests */
  featureRequests?: string;
  /** ID промпта, использованного для создания */
  promptId?: number;
  constructor(data?: IUpdateFeatureRequestDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property];
      }
      this.customer = _data["customer"];
      this.when = _data["when"];
      this.want = _data["want"];
      this.how = _data["how"];
      this.soThat = _data["soThat"];
      this.featureRequests = _data["featureRequests"];
      this.promptId = _data["promptId"];
    }
  }

  static fromJS(data: any): UpdateFeatureRequestDto {
    data = typeof data === "object" ? data : {};
    let result = new UpdateFeatureRequestDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property];
    }
    data["customer"] = this.customer;
    data["when"] = this.when;
    data["want"] = this.want;
    data["how"] = this.how;
    data["soThat"] = this.soThat;
    data["featureRequests"] = this.featureRequests;
    data["promptId"] = this.promptId;
    return data;
  }
}

export interface IUpdateFeatureRequestDto {
  /** Имя клиента */
  customer?: string;
  /** Когда происходит действие */
  when?: string;
  /** Что хочет клиент */
  want?: string;
  /** Как это должно работать */
  how?: string;
  /** Для чего это нужно */
  soThat?: string;
  /** Feature requests */
  featureRequests?: string;
  /** ID промпта, использованного для создания */
  promptId?: number;
}

export class CreatePromptDto implements ICreatePromptDto {
  /** Название промпта */
  name!: string;
  /** Текст промпта для AI агента */
  prompt!: string;
  constructor(data?: ICreatePromptDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property];
      }
      this.name = _data["name"];
      this.prompt = _data["prompt"];
    }
  }

  static fromJS(data: any): CreatePromptDto {
    data = typeof data === "object" ? data : {};
    let result = new CreatePromptDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property];
    }
    data["name"] = this.name;
    data["prompt"] = this.prompt;
    return data;
  }
}

export interface ICreatePromptDto {
  /** Название промпта */
  name: string;
  /** Текст промпта для AI агента */
  prompt: string;
}

export class PromptResponseDto implements IPromptResponseDto {
  /** Уникальный идентификатор */
  id!: number;
  /** Название промпта */
  name!: string;
  /** Текст промпта для AI агента */
  prompt!: string;
  /** Дата создания */
  createdAt!: Date;
  /** Дата последнего обновления */
  updatedAt!: Date;
  constructor(data?: IPromptResponseDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property];
      }
      this.id = _data["id"];
      this.name = _data["name"];
      this.prompt = _data["prompt"];
      this.createdAt = _data["createdAt"]
        ? new Date(_data["createdAt"].toString())
        : <any>undefined;
      this.updatedAt = _data["updatedAt"]
        ? new Date(_data["updatedAt"].toString())
        : <any>undefined;
    }
  }

  static fromJS(data: any): PromptResponseDto {
    data = typeof data === "object" ? data : {};
    let result = new PromptResponseDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property];
    }
    data["id"] = this.id;
    data["name"] = this.name;
    data["prompt"] = this.prompt;
    data["createdAt"] = this.createdAt
      ? this.createdAt.toISOString()
      : <any>undefined;
    data["updatedAt"] = this.updatedAt
      ? this.updatedAt.toISOString()
      : <any>undefined;
    return data;
  }
}

export interface IPromptResponseDto {
  /** Уникальный идентификатор */
  id: number;
  /** Название промпта */
  name: string;
  /** Текст промпта для AI агента */
  prompt: string;
  /** Дата создания */
  createdAt: Date;
  /** Дата последнего обновления */
  updatedAt: Date;
}

export class UpdatePromptDto implements IUpdatePromptDto {
  /** Название промпта */
  name?: string;
  /** Текст промпта для AI агента */
  prompt?: string;
  constructor(data?: IUpdatePromptDto) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      for (var property in _data) {
        if (_data.hasOwnProperty(property)) this[property] = _data[property];
      }
      this.name = _data["name"];
      this.prompt = _data["prompt"];
    }
  }

  static fromJS(data: any): UpdatePromptDto {
    data = typeof data === "object" ? data : {};
    let result = new UpdatePromptDto();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    for (var property in this) {
      if (this.hasOwnProperty(property)) data[property] = this[property];
    }
    data["name"] = this.name;
    data["prompt"] = this.prompt;
    return data;
  }
}

export interface IUpdatePromptDto {
  /** Название промпта */
  name?: string;
  /** Текст промпта для AI агента */
  prompt?: string;
}

export class SwaggerException extends Error {
  override message: string;
  status: number;
  response: string;
  headers: { [key: string]: any };
  result: any;

  constructor(
    message: string,
    status: number,
    response: string,
    headers: { [key: string]: any },
    result: any
  ) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isSwaggerException = true;

  static isSwaggerException(obj: any): obj is SwaggerException {
    return obj.isSwaggerException === true;
  }
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: { [key: string]: any },
  result?: any
): any {
  if (result !== null && result !== undefined) throw result;
  else throw new SwaggerException(message, status, response, headers, null);
}

function isAxiosError(obj: any): obj is AxiosError {
  return obj && obj.isAxiosError === true;
}
